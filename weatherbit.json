{"README.md":"# weatherbit [![Build Status](https://travis-ci.org/sparkfun/pxt-weather-bit.svg?branch=master)](https://travis-ci.org/sparkfun/pxt-weather-bit)\n\nTo use this package, go to https://makecode.microbit.org, click ``Add package`` and search for **weatherbit**.\n\n## Usage\n\nThe package adds support for the **weather:bit** add-on board from SparkFun.\n\n* [Weather Meters](https://www.sparkfun.com/products/8942)\n* [Soil Moisture Sensor](https://www.sparkfun.com/products/13322) (Analog Read) & [DS18B20 Soil Temperature Sensor](https://www.sparkfun.com/products/11050) (1-wire Digital Read)\n* Atmospheric Monitoring with the onboard [BME280](https://cdn.sparkfun.com/assets/learn_tutorials/4/1/9/BST-BME280_DS001-10.pdf) sensor (I2C)\n\t* Temperature\n\t* Humidity\n\t* Pressure\n\t* Altitude\t\n\n### Micro:bit Pins Used \n\nThe following micro:bit pins are used for weather, atmospheric and aquaponics monitoring:  \n\n* ``P0`` -- Soil Mositure Data \n* ``P1`` -- Wind Direction \n* ``P2`` -- Rain Data (in inches)\n* ``P8`` -- Wind Speed Data \n* ``P12`` -- Temperature Data \n* ``P14`` -- RXI (UART)\n* ``P15`` -- TXO (UART)\n* ``P16`` -- Soil Moisture Power \n* ``P19`` -- BME280 I2C - SCL\n* ``P20`` -- BME280 I2C - SDA \n\n### Set Up Function\nAt the start of any program which will use the BME280 Sensor data (Pressure, Humidity, Altitude, Temperature) place the \"Set up Weather Monitoring\" in a \"Forever\" block. \nIt is unknown at this time why this block will not work in the \"On Start\" block. \n\n### Start Monitoring Functions \n\nAt the start of any program which will use the \nweather meter data (Wind Speed, Wind Direction, Rain) \nplace the ``|start wind monitoring|`` and ``|start rain monitoring|`` \nin a ``|on start|`` block. \n\n```blocks\nweatherbit.startWindMonitoring();\nweatherbit.startRainMonitoring();\nweatherbit.startWeatherMonitoring()\n```\n\n### Atmospheric Data (BME280)\n\nThe BME280 sensor onboard the weather:bit communicates via I2C. The data is returned as a number which can be stored in a variable, shown on the LED matrix, or sent serially to OpenLog. \n* ``|temperature|``block returns a 4 digit number, when divided by 100 will provide the temperature in degree C with two decimals.\n* ``|humidity|`` block returns a 5 digit number, when divided by 1024 will provide the percent Relative Humidity.\n* ``|altitude|`` block returns altitude in meters rounded to the nearest whole number-given P0=1013.25hPa at seal level. (Absolute Altitude)\n* ``|pressure|``block returns an 8 digit number, when divided by 256 will provide the pressure in Pa. Diving again by 100 will provide measurement in hPa.\n\n\n```blocks\nbasic.forever(() => {\n    weatherbit.startWeatherMonitoring()\n})\nbasic.showNumber(weatherbit.temperature())\nbasic.showNumber(weatherbit.pressure())\nbasic.showNumber(weatherbit.humidity())\nbasic.showNumber(weatherbit.altitude())\n\n```\n\n### Aquaponics Data \n\nThe two central screw terminal blocks on the weather:bit provide space for the Soil Moisture Sensor and the DS18B20 Waterproof Temperature Sensor. Use the logical plug-in blocks to read \nthe soil moisture and temperature of the garden system.\n* ``|soil moisture|`` block returns a value between 0 and 1023. 0 being totally dry and 1023 being as wet as water. \n* ``|soil temperature|`` block a 4 digit number, when divided by 100 provides the temperature in hundreths of a degree centigrade. \n\n```blocks\nbasic.forever(() => {\n    basic.showNumber(weatherbit.soilTemperature())\n    basic.showNumber(weatherbit.soilMoisture())\n})\n```\n\n### Weather Meter Data\n\nUsing SparkFun's Weather Meters it is possible to obtain wind speed, inches of rain, and wind direction using weather:bit. \n* ``|wind speed|`` returns an integer-the wind speed in mph.\n* ``|wind direction|`` returns a string corresponding to the direction of the wind. (N, S, E, W, NE, NW, SE, SW)\n* ``|rain|`` returns an integer - inches of rain.\n\n```blocks\nbasic.forever(() => {\n    basic.showNumber(weatherbit.windSpeed())\n    basic.showString(weatherbit.windDirection())\n    basic.pause(300)\n    // serial.writeValue(\"wind direction\",\n    // weatherbit.windDirection())\n    basic.showNumber(weatherbit.rain())\n})\nweatherbit.startRainMonitoring()\n```\n\n### Serial Logging with OpenLog\n\nOpenLog is meant to be mated with the weather:bit with the SD card facing into the board. Make sure the RXI on Openlog connects to TXO on the weather:bit. \nUsing the ``|serial redirect|`` block\nchoose TX as P15 and RX as P14 at a baud rate of 9600. \nThe firmware on OpenLog will do the rest! \nWhen you want to review the data simple open the txt file created by OpenLog to view the data. \n\nExample Project:\nThe following project will read all atmospheric sensor data from the BME280 on button A press, will read all weather meter data on button B press, and aquaponics data on Button A+B press \nwith all values from all sensors logged to OpenLog. \n\n```blocks\ninput.onButtonPressed(Button.AB, () => {\n    basic.showNumber(weatherbit.soilTemperature())\n    serial.writeValue(\"soil temperature\", weatherbit.soilTemperature())\n    basic.showNumber(weatherbit.soilMoisture())\n    serial.writeValue(\"soil moisture\", weatherbit.soilMoisture())\n})\ninput.onButtonPressed(Button.A, () => {\n    basic.showNumber(weatherbit.temperature())\n    serial.writeValue(\"temperature\", weatherbit.temperature())\n    basic.showNumber(weatherbit.humidity())\n    serial.writeValue(\"humidity\", weatherbit.humidity())\n    basic.showNumber(weatherbit.pressure())\n    serial.writeValue(\"pressure\", weatherbit.pressure())\n    basic.showNumber(weatherbit.altitude())\n    serial.writeValue(\"altitude\", weatherbit.altitude())\n})\ninput.onButtonPressed(Button.B, () => {\n    basic.showNumber(weatherbit.windSpeed())\n    serial.writeValue(\"wind speed\", weatherbit.windSpeed())\n    basic.showString(weatherbit.windDirection())\n    basic.pause(300)\n    // serial.writeValue(\"wind direction\",\n    // weatherbit.windDirection())\n    basic.showNumber(weatherbit.rain())\n    serial.writeValue(\"rain\", weatherbit.rain())\n})\nweatherbit.startRainMonitoring()\nweatherbit.startWindMonitoring()\nweatherbit.startWeatherMonitoring()\nserial.redirect(\nSerialPin.P15,\nSerialPin.P14,\nBaudRate.BaudRate9600\n)\n```\n\n## License\n\nMIT\n\n## Supported targets\n\n* for PXT/microbit\n","_locales/fr/weatherbit-jsdoc-strings.json":"{\n  \"weatherbit\": \"Mary West @ SparkFun Electronics \\nRyan Mortenson https://github.com/ryanjmortenson\\nJune 13, 2017\\nhttps://github.com/sparkfun/pxt-weather-bit\\nDevelopment environment specifics:\\nWritten in Microsoft PXT\\nTested with a SparkFun weather:bit for micro:bit\\n* This code is released under the [MIT License](http://opensource.org/licenses/MIT).\\nPlease review the LICENSE.md file included with this example. If you have any questions \\nor concerns with licensing, please contact techsupport@sparkfun.com.\\nDistributed as-is; no warranty is given.\\n\\nFunctions to operate the weather:bit\\n\\nMary West @ SparkFun Electronics \\nRyan Mortenson https://github.com/ryanjmortenson\\nHarry Fairhead @ IoT-Programmer \\nJune 13, 2017\\nhttps://github.com/sparkfun/pxt-weather-bit\\n* Development environment specifics:\\nWritten in Microsoft PXT\\nTested with a SparkFun weather:bit for micro:bit\\n* This code is released under the [MIT License](http://opensource.org/licenses/MIT).\\nPlease review the LICENSE.md file included with this example. If you have any questions \\nor concerns with licensing, please contact techsupport@sparkfun.com.\\nDistributed as-is; no warranty is given.\",\n  \"weatherbit.altitude\": \"Lire le capteur de pression atmosphérique (altimètre), ajuster en fonction de la pression au niveau de la mer\\net retourner l'altitude absolue en mètres (m) avec deux décimales.\",\n  \"weatherbit.humidity\": \"Lire le capteur d’humidité (hygromètre), diviser le nombre de 5 chiffres par 1024 et retourner un résultat d'humidité relative (%).\",\n  \"weatherbit.pressure\": \"Lire le capteur de pression atmosphérique (baromètre), diviser le nombre de 8 chiffres par 25600\\net retourner un résultat en hectopascal (hPa) avec deux décimales.\",\n  \"weatherbit.rain\": \"Lire le capteur de précipitation (pluviomètre). Calculer la fréquence à laquelle la jauge se remplit et se vide.\\nRetourner la quantité en pouce de précipitations.\",\n  \"weatherbit.soilMoisture\": \"Lire le capteur d'humidité du sol et retourner un résultat entre 0 et 1023 (sur l’échelle analogique, 0 signifie sec et 1023 signifie humide).\\nCe n'est pas un hygromètre pour mesurer l'humidité de l'air ambiant, mais un circuit électrique mesurant la conductance du sol (l'eau est un conducteur d’électricité).\",\n  \"weatherbit.soilTemperature\": \"Lire la température à partir d'un capteur numérique, diviser le nombre de 4 chiffres par 100\\net retourner la température en centième de degrés Celsius.\",\n  \"weatherbit.startRainMonitoring\": \"Régler la broche P02 et activer la récolte des influx du pluviomètre.\\nLe pluviomètre capte les précipitations.\",\n  \"weatherbit.startWeatherMonitoring\": \"Activer le pilote de la carte BME. Cette carte capte des données atmosphériques grâce à ses capteurs de température,\\nd'humidité ambiante, de pression et d’altitude reliés par le protocole I2C. La carte peut aussi envoyer ses données par le protocole UART.\",\n  \"weatherbit.startWindMonitoring\": \"Activer l’anémométrie. Activer la récolte des influxdu capteur de la vitesse du vent (anémomètre).\",\n  \"weatherbit.temperature\": \"Lire le capteur de températures (thermomètre), diviser le nombre de 4 chiffres par 100\\net retourner un résultat en degrés Celsius (C) avec deux décimales.\",\n  \"weatherbit.windDirection\": \"Lire le capteur de la direction du vent (girouette).\\nRetourner une chaîne de caractères indiquant une des 8 directions (N, E, S, W, NE, NW, SE, SW).\",\n  \"weatherbit.windSpeed\": \"Lire le capteur de la vitesse du vent (anémomètre).\\nRetourner la vitesse en miles par heure (mph) chaque 2 secondes.\"\n}\n","_locales/fr/weatherbit-strings.json":"{\n  \"weatherbit.altitude|block\": \"altitude (M)\",\n  \"weatherbit.humidity|block\": \"humidité\",\n  \"weatherbit.pressure|block\": \"pression\",\n  \"weatherbit.rain|block\": \"précipitation\",\n  \"weatherbit.soilMoisture|block\": \"humidité du sol\",\n  \"weatherbit.soilTemperature|block\": \"température (C)\",\n  \"weatherbit.startRainMonitoring|block\": \"activé la pluviométrie\",\n  \"weatherbit.startWeatherMonitoring|block\": \"activer le contrôle météo\",\n  \"weatherbit.startWindMonitoring|block\": \"activé l'anémométrìe\",\n  \"weatherbit.temperature|block\": \"temperature (C)\",\n  \"weatherbit.windDirection|block\": \"wind direction\",\n  \"weatherbit.windSpeed|block\": \"vitesse du vent\",\n  \"weatherbit|block\": \"weatherbit\",\n  \"{id:category}Weatherbit\": \"Weatherbit\"\n}\n","enums.d.ts":"// Auto-generated. Do not edit.\ndeclare namespace weatherbit {\n}\n\n// Auto-generated. Do not edit. Really.\n","pxt.json":"{\n    \"name\": \"weatherbit\",\n    \"version\": \"0.0.15\",\n    \"description\": \"SparkFun weatherbit\",\n    \"license\": \"MIT\",\n    \"dependencies\": {\n        \"core\": \"*\"\n    },\n    \"files\": [\n        \"README.md\",\n        \"weatherbit.ts\",\n        \"weatherbit.cpp\",\n        \"shims.d.ts\",\n        \"enums.d.ts\",\n        \"_locales/fr/weatherbit-strings.json\",\n        \"_locales/fr/weatherbit-jsdoc-strings.json\"\n    ],\n    \"testFiles\": [\n        \"tests.ts\"\n    ],\n    \"public\": true,\n    \"targetVersions\": {\n        \"branch\": \"v3.0.20\",\n        \"tag\": \"v3.0.20\",\n        \"commits\": \"https://github.com/microsoft/pxt-microbit/commits/bbb11c936a7fe25f47780c8cc120196c17bc47f6\",\n        \"target\": \"3.0.20\",\n        \"pxt\": \"6.0.19\"\n    }\n}\n","shims.d.ts":"// Auto-generated. Do not edit.\n\n\n    /**\n     * Mary West @ SparkFun Electronics \n     * Ryan Mortenson https://github.com/ryanjmortenson\n     * Harry Fairhead @ IoT-Programmer \n     * June 13, 2017\n     * https://github.com/sparkfun/pxt-weather-bit\n     *\n     * Development environment specifics:\n     * Written in Microsoft PXT\n     * Tested with a SparkFun weather:bit for micro:bit\n     *\n     * This code is released under the [MIT License](http://opensource.org/licenses/MIT).\n     * Please review the LICENSE.md file included with this example. If you have any questions \n     * or concerns with licensing, please contact techsupport@sparkfun.com.\n     * Distributed as-is; no warranty is given.\n     */\n\ndeclare namespace weatherbit {\n}\n\n// Auto-generated. Do not edit. Really.\n","tests.ts":"// tests go here; this will not be compiled when this package is used as a library\ninput.onButtonPressed(Button.AB, () => {\n    basic.showNumber(weatherbit.soilTemperature())\n    serial.writeValue(\"soil temperature\", weatherbit.soilTemperature())\n    basic.showNumber(weatherbit.soilMoisture())\n    serial.writeValue(\"soil moisture\", weatherbit.soilMoisture())\n})\ninput.onButtonPressed(Button.A, () => {\n    basic.showNumber(weatherbit.temperature())\n    serial.writeValue(\"temperature\", weatherbit.temperature())\n    basic.showNumber(weatherbit.humidity())\n    serial.writeValue(\"humidity\", weatherbit.humidity())\n    basic.showNumber(weatherbit.pressure())\n    serial.writeValue(\"pressure\", weatherbit.pressure())\n    basic.showNumber(weatherbit.altitude())\n    serial.writeValue(\"altitude\", weatherbit.altitude())\n})\ninput.onButtonPressed(Button.B, () => {\n    basic.showNumber(weatherbit.windSpeed())\n    serial.writeValue(\"wind speed\", weatherbit.windSpeed())\n    basic.showString(weatherbit.windDirection())\n    basic.pause(300)\n    // serial.writeValue(\"wind direction\",\n    // weatherbit.readWindDirection())\n    basic.showNumber(weatherbit.rain())\n    serial.writeValue(\"rain\", weatherbit.rain())\n})\nweatherbit.startRainMonitoring()\nweatherbit.startWindMonitoring()\nweatherbit.startWeatherMonitoring()\n","weatherbit.cpp":"/**\n* Mary West @ SparkFun Electronics \n* Ryan Mortenson https://github.com/ryanjmortenson\n* Harry Fairhead @ IoT-Programmer \n* June 13, 2017\n* https://github.com/sparkfun/pxt-weather-bit\n*\n* Development environment specifics:\n* Written in Microsoft PXT\n* Tested with a SparkFun weather:bit for micro:bit\n*\n* This code is released under the [MIT License](http://opensource.org/licenses/MIT).\n* Please review the LICENSE.md file included with this example. If you have any questions \n* or concerns with licensing, please contact techsupport@sparkfun.com.\n* Distributed as-is; no warranty is given.\n*/\n\n\n#include \"pxt.h\"\n#include <cstdint>\n#include <math.h>\n\nusing namespace pxt;\n\n// v0 backward compat support\n#ifndef PXT_BUFFER_DATA\n#define PXT_BUFFER_DATA(buffer) buffer->payload\n#endif\n\nnamespace weatherbit {    \n\tMicroBitPin P12(MICROBIT_ID_IO_P12, MICROBIT_PIN_P12, PIN_CAPABILITY_DIGITAL); \n    MicroBitPin P13(MICROBIT_ID_IO_P13, MICROBIT_PIN_P13, PIN_CAPABILITY_DIGITAL); \n\n    uint8_t init() {\n        P12.setDigitalValue(0);\n        for (volatile uint16_t i = 0; i < 600; i++);\n        P12.setDigitalValue(1);\n        for (volatile uint8_t i = 0; i < 30; i++);\n        int b = P13.getDigitalValue();\n        for (volatile uint16_t i = 0; i < 600; i++);\n        return b;\n    }\n\n    void sendZero() {\n        P12.setDigitalValue(0);\n        for (volatile uint8_t i = 1; i < 75; i++);\n        P12.setDigitalValue(1);\n        for (volatile uint8_t i = 1; i < 6; i++);\n    }\n\n    void sendOne() {\n        P12.setDigitalValue(0);\n        for (volatile uint8_t i = 1; i < 1; i++);\n        P12.setDigitalValue(1);\n        for (volatile uint8_t i = 1; i < 80; i++);\n    }\n\n    void writeBit(int b) {\n        int delay1, delay2;\n        if (b == 1) {\n            delay1 = 1;\n            delay2 = 80;\n        } else {\n            delay1 = 75;\n            delay2 = 6;\n        }\n        P12.setDigitalValue(0);\n        for (uint8_t i = 1; i < delay1; i++);\n        P12.setDigitalValue(1);\n        for (uint8_t i = 1; i < delay2; i++);\n    }\n\n    void sendskip() {\n        writeBit(0);\n        writeBit(0);\n        writeBit(1);\n        writeBit(1);\n        writeBit(0);\n        writeBit(0);\n        writeBit(1);\n        writeBit(1);\n    }\n\n    void writeByte(int byte) {\n        int i;\n        for (i = 0; i < 8; i++) {\n            if (byte & 1) {\n                writeBit(1);\n            } else {\n                writeBit(0);\n            }\n            byte = byte >> 1;\n        }\n    }\n\n    int readBit() {\n        volatile int i;\n        P12.setDigitalValue(0);\n        P12.setDigitalValue(1);\n        for (i = 1; i < 20; i++);\n        int b = P13.getDigitalValue();\n        for (i = 1; i < 60; i++);\n        return b;\n    }\n\n    int convert() {\n        volatile int i;\n        int j;\n        writeByte(0x44);\n        for (j = 1; j < 1000; j++) {\n            for (i = 1; i < 900; i++) {\n        };\n        if (readBit() == 1)\n            break;\n        };\n        return (j);\n    }\n\n    int readByte() {\n        int byte = 0;\n        int i;\n        for (i = 0; i < 8; i++) {\n            byte = byte | readBit() << i;\n        };\n        return byte;\n    }\n\n    //%\n    int16_t soilTemp() {\n        init();\n        writeByte(0xCC);\n        convert();\n        init();\n        writeByte(0xCC);\n        writeByte(0xBE);\n        int b1 = readByte();\n        int b2 = readByte();\n\n        int16_t temp = (b2 << 8 | b1);\n        return temp * 100 / 16;\n    }\n\n\n    /*\n    * Compensates the pressure value read from the register.  This done in C++ because\n    * it requires the use of 64-bit signed integers which isn't provided in TypeScript\n    */\n    //%\n    uint32_t compensatePressure(int32_t pressRegVal, int32_t tFine, Buffer compensation) {\n        // Compensation Values\n        uint16_t digP1;\n        int16_t digP2;\n        int16_t digP3;\n        int16_t digP4;\n        int16_t digP5;\n        int16_t digP6;\n        int16_t digP7;\n        int16_t digP8;\n        int16_t digP9;\n\n        // Unpack the compensation data        \n        auto ptr = PXT_BUFFER_DATA(compensation);\n        memcpy((uint8_t *) &digP1, ptr + 0, 2);\n        memcpy((uint8_t *) &digP2, ptr + 2, 2);\n        memcpy((uint8_t *) &digP3, ptr + 4, 2);\n        memcpy((uint8_t *) &digP4, ptr + 6, 2);\n        memcpy((uint8_t *) &digP5, ptr + 8, 2);\n        memcpy((uint8_t *) &digP6, ptr + 10, 2);\n        memcpy((uint8_t *) &digP7, ptr + 12, 2);\n        memcpy((uint8_t *) &digP8, ptr + 14, 2);\n        memcpy((uint8_t *) &digP9, ptr + 16, 2);\n\n        // Do the compensation\n        int64_t firstConv = ((int64_t) tFine) - 128000;\n        int64_t secondConv = firstConv * firstConv * (int64_t)digP6;\n        secondConv = secondConv + ((firstConv*(int64_t)digP5)<<17);\n        secondConv = secondConv + (((int64_t)digP4)<<35);\n        firstConv = ((firstConv * firstConv * (int64_t)digP3)>>8) + ((firstConv * (int64_t)digP2)<<12);\n        firstConv = (((((int64_t)1)<<47)+firstConv))*((int64_t)digP1)>>33;\n        if (firstConv == 0) {\n            return 0; // avoid exception caused by division by zero\n        }\n        int64_t p = 1048576-pressRegVal;\n        p = (((p<<31)-secondConv)*3125)/firstConv;\n        firstConv = (((int64_t)digP9) * (p>>13) * (p>>13)) >> 25;\n        secondConv = (((int64_t)digP8) * p) >> 19;\n        p = ((p + firstConv + secondConv) >> 8) + (((int64_t)digP7)<<4);\n        return (uint32_t)p;\n    }\n\n    /*\n    * calculates the Altitude based on pressure. \n    */\n    //%    \n    uint32_t calcAltitude(int32_t pressRegVal, int32_t tFine, Buffer compensation) {\n       \n        return 44330*(1-pow(((compensatePressure(pressRegVal, tFine, compensation)/25600)/1013.25), 0.1903));\n    }\n}\n","weatherbit.ts":"/**\n* Mary West @ SparkFun Electronics \n* Ryan Mortenson https://github.com/ryanjmortenson\n* June 13, 2017\n* https://github.com/sparkfun/pxt-weather-bit\n\n* Development environment specifics:\n* Written in Microsoft PXT\n* Tested with a SparkFun weather:bit for micro:bit\n*\n* This code is released under the [MIT License](http://opensource.org/licenses/MIT).\n* Please review the LICENSE.md file included with this example. If you have any questions \n* or concerns with licensing, please contact techsupport@sparkfun.com.\n* Distributed as-is; no warranty is given.\n*\n* This is a new comment!\n*\n*/\n\n\n/**\n * Functions to operate the weather:bit\n */\n\n//% color=#f44242 icon=\"\\u26C8\"\nnamespace weatherbit {\n    // keep track of services\n    let rainMonitorStarted = false;\n    let windMonitorStarted = false;\n    let weatherMonitorStarted = false;\n    // Keep Track of weather monitoring variables\n    let numRainDumps = 0\n    let numWindTurns = 0\n    let windMPH = 0\n\n    // BME280 Addresses\n    const bmeAddr = 0x76\n    const ctrlHum = 0xF2\n    const ctrlMeas = 0xF4\n    const config = 0xF5\n    const pressMSB = 0xF7\n    const pressLSB = 0xF8\n    const pressXlsb = 0xF9\n    const tempMSB = 0xFA\n    const tempLSB = 0xFB\n    const tempXlsb = 0xFC\n    const humMSB = 0xFD\n    const humLSB = 0xFE\n\n    // Stores compensation values for Temperature (must be read from BME280 NVM)\n    let digT1Val = 0\n    let digT2Val = 0\n    let digT3Val = 0\n\n    // Stores compensation values for humidity (must be read from BME280 NVM)\n    let digH1Val = 0\n    let digH2Val = 0\n    let digH3Val = 0\n    let digH4Val = 0\n    let digH5Val = 0\n    let digH6Val = 0\n\n    // Buffer to hold pressure compensation values to pass to the C++ compensation function\n    let digPBuf: Buffer\n\n    // BME Compensation Parameter Addresses for Temperature\n    const digT1 = 0x88\n    const digT2 = 0x8A\n    const digT3 = 0x8C\n\n    // BME Compensation Parameter Addresses for Pressure\n    const digP1 = 0x8E\n    const digP2 = 0x90\n    const digP3 = 0x92\n    const digP4 = 0x94\n    const digP5 = 0x96\n    const digP6 = 0x98\n    const digP7 = 0x9A\n    const digP8 = 0x9C\n    const digP9 = 0x9E\n\n    // BME Compensation Parameter Addresses for Humidity\n    const digH1 = 0xA1\n    const digH2 = 0xE1\n    const digH3 = 0xE3\n    const e5Reg = 0xE5\n    const e4Reg = 0xE4\n    const e6Reg = 0xE6\n    const digH6 = 0xE7\n\n    // Functions for interfacing with the Weather Meters\n\n    export function rainReset(bias:number): number {\n         numRainDumps = bias;\n        return rain();\n    }\n\n    /**\n    * Reads the number of times the rain gauge has filled and emptied\n\t* Returns inches of rain. \n    */\n    //% weight=30 blockId=\"weatherbit_rain\" block=\"rain\"\n    export function rain(): number {\n        startRainMonitoring();\n        // Will be zero until numRainDumps is greater than 90 = 1\"\n        let inchesOfRain = ((numRainDumps * 11) / 1000)\n        return inchesOfRain\n    }\n\n    /**\n    * Sets up an event on pin 2 pulse high and event handler to increment rain\n    * numRainDumps on said event.\n    */\n    //% weight=31 blockGap=8  blockId=\"weatherbit_startRainMonitoring\" block=\"start rain monitoring\"\n    export function startRainMonitoring(): void {\n        if (rainMonitorStarted) return;\n\n        pins.setPull(DigitalPin.P2, PinPullMode.PullUp)\n\n        // Watch pin 2 for a high pulse and send an event\n        pins.onPulsed(DigitalPin.P2, PulseValue.High, () => {\n            control.raiseEvent(\n                EventBusSource.MICROBIT_ID_IO_P2,\n                EventBusValue.MICROBIT_PIN_EVT_RISE\n            )\n        })\n\n        // Register event handler for a pin 2 high pulse\n        control.onEvent(EventBusSource.MICROBIT_ID_IO_P2, EventBusValue.MICROBIT_PIN_EVT_RISE, () => {\n            numRainDumps++\n        })\n\n        // only init once\n        rainMonitorStarted = true;\n    }\n\n    /**\n    * Read the wind direction from the wind vane.  \n\t* Retuns a string representing the direction (N, E, S, W, NE, NW, SE, SW)\n    */\n    //% weight=20 blockId=\"weatherbit_windDir\" block=\"wind direction\"\n    export function windDirection(): string {\n        startWindMonitoring();\n\n        let windDir = 0\n        windDir = pins.analogReadPin(AnalogPin.P1)\n        if (windDir < 906 && windDir > 886)\n            return \"N\"\n        else if (windDir < 712 && windDir > 692)\n            return \"NE\"\n        else if (windDir < 415 && windDir > 395)\n            return \"E\"\n        else if (windDir < 498 && windDir > 478)\n            return \"SE\"\n        else if (windDir < 584 && windDir > 564)\n            return \"S\"\n        else if (windDir < 819 && windDir > 799)\n            return \"SW\"\n        else if (windDir < 988 && windDir > 968)\n            return \"W\"\n        else if (windDir < 959 && windDir > 939)\n            return \"NW\"\n        else\n            return \"???\"\n    }\n\n    /**\n    * Read the instaneous wind speed form the Anemometer. Starting the wind\n    * speed monitoring updates the wind in MPH every 2 seconds.\n    */\n    //% weight=21 blockGap=8 blockId=\"weatherbit_windSpeed\" block=\"wind speed\"\n    export function windSpeed(): number {\n        startWindMonitoring();\n\n        return windMPH\n    }\n\n    /**\n    * Sets up an event on pin 8 pulse high and event handler to increment\n    * numWindTurns on said event.  Starts background service to reset\n    * numWindTurns every 2 seconds and calculate MPH.\n    */\n    //% weight=22 blockGap=8 blockId=\"weatherbit_startWindMonitoring\" block=\"start wind monitoring\"\n    export function startWindMonitoring(): void {\n        if (windMonitorStarted) return;\n\n        pins.setPull(DigitalPin.P8, PinPullMode.PullUp)\n\n        // Watch pin 8 for a high pulse and send an event\n        pins.onPulsed(DigitalPin.P8, PulseValue.High, () => {\n            control.raiseEvent(\n                EventBusSource.MICROBIT_ID_IO_P8,\n                EventBusValue.MICROBIT_PIN_EVT_RISE\n            )\n        })\n\n        // Register event handler for a pin 8 high pulse\n        control.onEvent(EventBusSource.MICROBIT_ID_IO_P8, EventBusValue.MICROBIT_PIN_EVT_RISE, () => {\n            numWindTurns++\n        })\n\n        // Update MPH value every 2 seconds\n        control.inBackground(() => {\n            while (true) {\n                basic.pause(2000)\n                windMPH = (numWindTurns / 2) / (1492 / 1000)\n                numWindTurns = 0\n            }\n        })\n\n        windMonitorStarted = true;\n    }\n\n    /***************************************************************************************\n     * Functions for interfacing with the BME280\n     ***************************************************************************************/\n\n    /**\n     * Writes a value to a register on the BME280\n     */\n    function WriteBMEReg(reg: number, val: number): void {\n        pins.i2cWriteNumber(bmeAddr, reg << 8 | val, NumberFormat.Int16BE)\n    }\n\n    /**\n     * Reads a value from a register on the BME280\n     */\n    function readBMEReg(reg: number, format: NumberFormat) {\n        pins.i2cWriteNumber(bmeAddr, reg, NumberFormat.UInt8LE, false)\n        let val = pins.i2cReadNumber(bmeAddr, format, false)\n        return val\n    }\n\n    /**\n     * Reads the temp from the BME sensor and uses compensation for calculator temperature.\n     * Returns 4 digit number. Value should be devided by 100 to get DegC\n     */\n    //% weight=43 blockGap=8 blockId=\"weatherbit_temperature\" block=\"temperature(C)\"\n    export function temperature(): number {\n        // Read the temperature registers\n        let tempRegM = readBMEReg(tempMSB, NumberFormat.UInt16BE)\n        let tempRegL = readBMEReg(tempXlsb, NumberFormat.UInt8LE)\n\n        // Use compensation formula and return result\n        return compensateTemp((tempRegM << 4) | (tempRegL >> 4))\n    }\n\n    /**\n     * Reads the humidity from the BME sensor and uses compensation for calculating humidity.\n     * returns a 5 digit number. Value should be divided by 1024 to get % relative humidity. \n     */\n    //% weight=41 blockGap=8 blockId=\"weatherbit_humidity\" block=\"humidity\"\n    export function humidity(): number {\n        // Read the pressure registers\n        let humReg = readBMEReg(humMSB, NumberFormat.UInt16BE)\n\n        // Compensate and return humidity\n        return compensateHumidity(humReg)\n    }\n\n    /**\n     * Reads the pressure from the BME sensor and uses compensation for calculating pressure.\n     * Returns an 8 digit number. Value should be divided by 25600 to get hPa. \n     */\n    //% weight=42 blockGap=8 blockId=\"pressure\" block=\"pressure\"\n    export function pressure(): number {\n        // Read the temperature registers\n        let pressRegM = readBMEReg(pressMSB, NumberFormat.UInt16BE)\n        let pressRegL = readBMEReg(pressXlsb, NumberFormat.UInt8LE)\n\n        // Compensate and return pressure\n        return compensatePressure((pressRegM << 4) | (pressRegL >> 4), tFine, digPBuf)\n    }\n\n    /**\n     * Sets up BME for in Weather Monitoring Mode.\n     */\n    //% weight=44 blockGap=8 blockId=\"weatherbit_setupBME280\" block=\"start weather monitoring\"\n    export function startWeatherMonitoring(): void {\n        if (weatherMonitorStarted) return;\n\n        // The 0xE5 register is 8 bits where 4 bits go to one value and 4 bits go to another\n        let e5Val = 0\n\n        // Instantiate buffer that holds the pressure compensation values\n        digPBuf = pins.createBuffer(18)\n\n        // Set up the BME in weather monitoring mode\n        WriteBMEReg(ctrlHum, 0x01)\n        WriteBMEReg(ctrlMeas, 0x27)\n        WriteBMEReg(config, 0)\n\n        // Read the temperature registers to do a calculation and set tFine\n        let tempRegM = readBMEReg(tempMSB, NumberFormat.UInt16BE)\n        let tempRegL = readBMEReg(tempXlsb, NumberFormat.UInt8LE)\n\n        // Get the NVM digital compensations numbers from the device for temp\n        digT1Val = readBMEReg(digT1, NumberFormat.UInt16LE)\n        digT2Val = readBMEReg(digT2, NumberFormat.Int16LE)\n        digT3Val = readBMEReg(digT3, NumberFormat.Int16LE)\n\n        // Get the NVM digital compensation number from the device for pressure and pack into\n        // a buffer to pass to the C++ implementation of the compensation formula\n        digPBuf.setNumber(NumberFormat.UInt16LE, 0, readBMEReg(digP1, NumberFormat.UInt16LE))\n        digPBuf.setNumber(NumberFormat.Int16LE, 2, readBMEReg(digP2, NumberFormat.Int16LE))\n        digPBuf.setNumber(NumberFormat.Int16LE, 4, readBMEReg(digP3, NumberFormat.Int16LE))\n        digPBuf.setNumber(NumberFormat.Int16LE, 6, readBMEReg(digP4, NumberFormat.Int16LE))\n        digPBuf.setNumber(NumberFormat.Int16LE, 8, readBMEReg(digP5, NumberFormat.Int16LE))\n        digPBuf.setNumber(NumberFormat.Int16LE, 10, readBMEReg(digP6, NumberFormat.Int16LE))\n        digPBuf.setNumber(NumberFormat.Int16LE, 12, readBMEReg(digP7, NumberFormat.Int16LE))\n        digPBuf.setNumber(NumberFormat.Int16LE, 14, readBMEReg(digP8, NumberFormat.Int16LE))\n        digPBuf.setNumber(NumberFormat.Int16LE, 16, readBMEReg(digP9, NumberFormat.Int16LE))\n\n        // Get the NVM digital compensation number from device for humidity\n        e5Val = readBMEReg(e5Reg, NumberFormat.Int8LE)\n        digH1Val = readBMEReg(digH1, NumberFormat.UInt8LE)\n        digH2Val = readBMEReg(digH2, NumberFormat.Int16LE)\n        digH3Val = readBMEReg(digH3, NumberFormat.UInt8LE)\n        digH4Val = (readBMEReg(e4Reg, NumberFormat.Int8LE) << 4) | (e5Val & 0xf)\n        digH5Val = (readBMEReg(e6Reg, NumberFormat.Int8LE) << 4) | (e5Val >> 4)\n        digH6Val = readBMEReg(digH6, NumberFormat.Int8LE)\n\n        // Compensate the temperature to calcule the tFine variable for use in other\n        // measurements\n        let temp = compensateTemp((tempRegM << 4) | (tempRegL >> 4))\n\n        weatherMonitorStarted = true;\n    }\n\n    // Global variable used in all calculations for the BME280\n    let tFine = 0\n\n    /**\n     * Returns temperature in DegC, resolution is 0.01 DegC. Output value of “5123” equals 51.23 DegC.\n     * tFine carries fine temperature as global value\n     */\n    function compensateTemp(tempRegVal: number): number {\n        let firstConv: number = (((tempRegVal >> 3) - (digT1Val << 1)) * digT2Val) >> 11\n        let secConv: number = (((((tempRegVal >> 4) - digT1Val) * ((tempRegVal >> 4) - (digT1Val))) >> 12) * (digT3Val)) >> 14\n        tFine = firstConv + secConv\n        return (tFine * 5 + 128) >> 8\n    }\n\n    /**\n     * Returns humidity in %RH as unsigned 32 bit integer in Q22.10 format (22 integer and 10 fractional bits).\n     * Output value of “47445” represents 47445/1024 = 46.333 %RH\n     */\n    function compensateHumidity(humRegValue: number): number {\n        let hum: number = (tFine - 76800)\n        hum = (((((humRegValue << 14) - (digH4Val << 20) - (digH5Val * hum)) + 16384) >> 15) * (((((((hum * digH6Val) >> 10) * (((hum * digH3Val) >> 11) + 32768)) >> 10) + 2097152) * digH2Val + 8192) >> 14))\n        hum = hum - (((((hum >> 15) * (hum >> 15)) >> 7) * digH1Val) >> 4)\n        hum = (hum < 0 ? 0 : hum)\n        hum = (hum > 419430400 ? 419430400 : hum)\n        return (hum >> 12)\n    }\n\n    /**\n     * Function used for simulator, actual implementation is in weatherbit.cpp\n     */\n    //% shim=weatherbit::compensatePressure\n    function compensatePressure(pressRegVal: number, tFine: number, compensation: Buffer) {\n        // Fake function for simulator\n        return 0\n    }\n\n    /**\n   * Reads the pressure from the BME sensor and uses compensation for calculating pressure.\n   * Returns altitude in meters based on pressure at sea level. (absolute altitude)\n   */\n    //% weight=40 blockGap=28 blockId=\"weatherbit_altitude\" block=\"altitude(M)\"\n    export function altitude(): number {\n        startWeatherMonitoring();\n\n        let pressRegM = readBMEReg(pressMSB, NumberFormat.UInt16BE)\n        let pressRegL = readBMEReg(pressXlsb, NumberFormat.UInt8LE)\n        return calcAltitude((pressRegM << 4) | (pressRegL >> 4), tFine, digPBuf)\n    }\n\n    /**\n     * Function used for simulator, actual implementation is in weatherbit.cpp\n     */\n    //% shim=weatherbit::calcAltitude\n    function calcAltitude(pressRegVal: number, tFine: number, compensation: Buffer) {\n        // Fake function for simulator\n        return 0\n    }\n\n\n    // Functions for interfacing with the soil moisture and soil temperature (aquaponics)\n\n\n    /**\n     * Reads the Moisture Level from the Soil Moisture Sensor.\n\t * Returns a value between 0 and 1023. 0 being dry and 1023 being wet.     \n     */\n    //% weight=11 blockGap=8 blockId=\"weatherbit_soilMoisture\" block=\"soil moisture\"\n    export function soilMoisture(): number {\n        let soilMoisture = 0\n        pins.digitalWritePin(DigitalPin.P16, 1)\n        basic.pause(10)\n        soilMoisture = pins.analogReadPin(AnalogPin.P0)\n        basic.pause(1000)\n        pins.digitalWritePin(DigitalPin.P16, 0)\n        return soilMoisture\n    }\n    /**\n     * Reads the temperature from the one-wire temperature sensor.\n\t * Returns a 4 digit number. value should be divided by 100 to get \n\t *temperature in hudnreths of a degree centigrade. \n     */\n    //% weight=10 blockId=\"weahterbit_soilTemp\" block=\"soil temperature(C)\"\n    //% shim=weatherbit::soilTemp\n    export function soilTemperature(): number {\n        // Fake function for simulator\n        return 0\n    }\n}\n"}